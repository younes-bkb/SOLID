# üß± SOLID - Principes de Conception Orient√©e Objet

Cette section regroupe des fiches simples et synth√©tiques sur les principes de conception **SOLID**. Acronyme introduit par Robert C. Martin ("Uncle Bob"), ces cinq principes sont des lignes directrices fondamentales pour √©crire du logiciel maintenable, extensible, et robuste en programmation orient√©e objet.

Chaque fiche est con√ßue pour √™tre claire, illustr√©e d'exemples concrets "avant/apr√®s" en PHP, afin de comprendre non seulement le principe, mais aussi comment l'appliquer pour am√©liorer la qualit√© de votre code.

## üìÇ Contenu

-   [**01-single-responsibility-principle.md**](./01-single-responsibility-principle.md) : **S** - Single Responsibility Principle (Principe de Responsabilit√© Unique)
-   [**02-open-closed-principle.md**](./02-open-closed-principle.md) : **O** - Open/Closed Principle (Principe Ouvert/Ferm√©)
-   [**03-liskov-substitution-principle.md**](./03-liskov-substitution-principle.md) : **L** - Liskov Substitution Principle (Principe de Substitution de Liskov)
-   [**04-interface-segregation-principle.md**](./04-interface-segregation-principle.md) : **I** - Interface Segregation Principle (Principe de S√©gr√©gation d'Interface)
-   [**05-dependency-inversion-principle.md**](./05-dependency-inversion-principle.md) : **D** - Dependency Inversion Principle (Principe d'Inversion de D√©pendance)

## üéØ Objectif

Ces fiches permettent de :

-   Comprendre en profondeur chacun des cinq principes SOLID.
-   Identifier les violations de ces principes dans du code existant (les "code smells").
-   Apprendre √† refactoriser du code pour le rendre conforme aux principes SOLID.
-   √âcrire du code plus facile √† maintenir, √† tester et √† faire √©voluer.

## üîß Pourquoi les principes SOLID ?

Le respect des principes SOLID m√®ne √† une conception logicielle de meilleure qualit√©, avec des b√©n√©fices concrets :

-   **Maintenabilit√© :** Le code est plus simple √† comprendre et √† corriger, car les responsabilit√©s sont clairement d√©limit√©es.
-   **Extensibilit√© :** Ajouter de nouvelles fonctionnalit√©s devient plus facile et moins risqu√©, souvent sans avoir √† modifier le code existant.
-   **Testabilit√© :** Les classes plus petites et plus cibl√©es sont beaucoup plus faciles √† tester unitairement.
-   **Lisibilit√© :** Le code est mieux organis√©, plus logique et plus facile √† lire pour les autres d√©veloppeurs (et pour vous-m√™me dans le futur).
